description = "The core classes of Embulk, a pluggable multi-source/destination bulk data loader."

repositories {
    mavenCentral()
}

configurations {
    compileClasspath.resolutionStrategy.activateDependencyLocking()
    runtimeClasspath.resolutionStrategy.activateDependencyLocking()
}

// determine which dependencies have updates: $ gradle dependencyUpdates
dependencies {
    // Embulk plugins have expected that embulk-core's dependencies are declared as "compile" in pom.xml.
    // Although those dependencies would be finally removed from embulk-core's direct dependencies,
    // those "compile" declaration would be kept so that plugin developers won't be confused unnecessarily.
    api project(":embulk-api")
    api project(":embulk-spi")
    api "com.google.guava:guava:18.0"
    api "com.google.inject:guice:4.0"
    api "com.google.inject.extensions:guice-multibindings:4.0"
    api "javax.inject:javax.inject:1"

    testImplementation "junit:junit:4.12"
    testImplementation "ch.qos.logback:logback-classic:1.1.3"

    // TODO: Remove this, and load it with the proper DependencyClassLoader.
    // This statement gets it loaded by the top-level ClassLoader.
    testImplementation project(":embulk-deps")
}

test {
    dependsOn ":test-helpers:deploy"
    maxHeapSize = "1536m"
    forkEvery = 1  // test processes are forked by each test class (default is 0)
}

import java.util.zip.ZipFile
task updateResources(dependsOn: 'prepareDependencyJars') {
    doFirst {
        List<String> packages = []
        List<String> dirs = []
        file("${buildDir}/dependency_jars").listFiles().each { jarFile ->
            List<String> names = new ZipFile(jarFile.toString()).entries().iterator().collect { it.getName() }
            packages.addAll(names.findAll { it.endsWith(".class") }.collect { it.replaceFirst(/(?:^|\/)[^\/]*\.class$/, '').replaceAll(/\//, '.') }.unique())
            dirs.addAll(names.findAll { !it.endsWith("/") && !it.endsWith(".class") }.collect { it.replaceFirst(/(?:^|\/)[^\/]*$/, '') }.unique())
        }
        packages = packages.unique()
        dirs = dirs.unique()
        List<String> uniquePackages = packages.clone()
        List<String> uniqueDirs = dirs.clone()
        packages.each { pk -> uniquePackages.removeAll { it.startsWith(pk + '.') } }
        dirs.each { dir -> uniqueDirs.removeAll { it.startsWith(dir + '/') } }
        uniquePackages.removeAll { it.isEmpty() }
        uniqueDirs.removeAll { it.isEmpty() || it == "META-INF" }
        String date = new Date().format('yyyy-MM-dd HH:mm:ss z', TimeZone.getTimeZone("UTC"))
        file("src/main/resources/embulk/parent_first_packages.properties").withWriter { out ->
            out.println("# generated by './gradlew updateResources' at $date")
            uniquePackages.sort().each { out.println it }
        }
        file("src/main/resources/embulk/parent_first_resources.properties").withWriter { out ->
            out.println("# generated by './gradlew updateResources' at $date")
            uniqueDirs.sort().each { out.println it }
        }
    }
    doLast {
        prepareDependencyJars.execute()
    }
}

task prepareDependencyJars(type: Copy) {
    doFirst {
        delete file("${buildDir}/dependency_jars")
        mkdir file("${buildDir}/dependency_jars")
    }
    into "${buildDir}/dependency_jars"
    from configurations.runtimeClasspath
    from jar.outputs.files
}
